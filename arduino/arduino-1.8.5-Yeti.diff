diff -urN arduino-1.8.5.orig/hardware/arduino/avr/boards.txt arduino-1.8.5/hardware/arduino/avr/boards.txt
--- arduino-1.8.5.orig/hardware/arduino/avr/boards.txt	2017-10-02 15:37:15.000000000 +0200
+++ arduino-1.8.5/hardware/arduino/avr/boards.txt	2017-10-06 16:07:40.806067310 +0200
@@ -1051,3 +1051,45 @@
 unowifi.build.variant=standard
 unowifi.build.esp_ch_uart_br=19200
 unowifi.build.extra_flags=-DESP_CH_UART -DESP_CH_UART_BR={build.esp_ch_uart_br}
+
+##############################################################
+bbArduino.name=YETI Wireless
+bbArduino.upload.tool=avrdude
+bbArduino.upload.protocol=arduino
+bbArduino.upload.maximum_size=30720
+bbArduino.upload.speed=2400
+
+bbArduino.bootloader.tool=avrdude
+bbArduino.bootloader.low_fuses=0xFF
+bbArduino.bootloader.high_fuses=0xDA
+bbArduino.bootloader.extended_fuses=0xFD
+bbArduino.bootloader.file=yeti/ATmegaBOOT_168_atmega328ir.hex
+bbArduino.bootloader.unlock_bits=0x3F
+bbArduino.bootloader.lock_bits=0x0F
+
+bbArduino.build.mcu=atmega328p
+bbArduino.build.f_cpu=16000000L
+bbArduino.build.core=arduino
+bbArduino.build.variant=standard
+bbArduino.build.board=YETI_WIRELESS
+
+##############################################################
+bbArduinoF.name=YETI Wired High-Speed
+bbArduinoF.upload.tool=avrdude
+bbArduinoF.upload.protocol=arduino
+bbArduinoF.upload.maximum_size=30720
+bbArduinoF.upload.speed=57600
+
+bbArduinoF.bootloader.tool=avrdude
+bbArduinoF.bootloader.low_fuses=0xFF
+bbArduinoF.bootloader.high_fuses=0xDA
+bbArduinoF.bootloader.extended_fuses=0xFD
+bbArduinoF.bootloader.file=yeti/ATmegaBOOT_168_atmega328ir.hex
+bbArduinoF.bootloader.unlock_bits=0x3F
+bbArduinoF.bootloader.lock_bits=0x0F
+
+bbArduinoF.build.mcu=atmega328p
+bbArduinoF.build.f_cpu=16000000L
+bbArduinoF.build.core=arduino
+bbArduinoF.build.variant=standard
+bbArduinoF.build.board=YETI_WIRED
diff -urN arduino-1.8.5.orig/hardware/arduino/avr/bootloaders/yeti/ATmegaBOOT_168_atmega328ir.hex arduino-1.8.5/hardware/arduino/avr/bootloaders/yeti/ATmegaBOOT_168_atmega328ir.hex
--- arduino-1.8.5.orig/hardware/arduino/avr/bootloaders/yeti/ATmegaBOOT_168_atmega328ir.hex	1970-01-01 01:00:00.000000000 +0100
+++ arduino-1.8.5/hardware/arduino/avr/bootloaders/yeti/ATmegaBOOT_168_atmega328ir.hex	2017-10-06 14:44:59.796003795 +0200
@@ -0,0 +1,102 @@
+:107800000C94343C0C94513C0C94513C0C94513CE1
+:107810000C94513C0C94513C0C94513C0C94513CB4
+:107820000C94513C0C94513C0C94513C0C94513CA4
+:107830000C94513C0C94513C0C94513C0C94513C94
+:107840000C94513C0C94513C0C94513C0C94513C84
+:107850000C94513C0C94513C0C94513C0C94513C74
+:107860000C94513C0C94513C11241FBECFEFD8E036
+:10787000DEBFCDBF11E0A0E0B1E0EEE2FEE702C066
+:1078800005900D92A230B107D9F712E0A2E0B1E065
+:1078900001C01D92AD30B107E1F70E94263D0C9466
+:1078A000153F0C94003C9091C00095FFFCCF909147
+:1078B000C1009F7E9093C1008093C6008091C0005C
+:1078C00086FFFCCF8FE19EE40197F1F700C0000036
+:1078D0008091C10080618093C10008951F93982F0B
+:1078E0009595959595959595905D182F1F701A30E3
+:1078F00014F0195A01C0105D892F0E94533C812F4A
+:107900000E94533C1F91089515C02D9A2FEF31EE20
+:1079100044E0215030404040E1F700C000002D9885
+:107920002FEF31EE44E0215030404040E1F700C0FD
+:1079300000008150882349F70895E0EBF0E0808152
+:107940008F7B8083239810821092B1001092B30035
+:10795000E0910401F091050109950895EF92FF92DD
+:107960000F931F93EE24FF24870110C00894E11C9D
+:10797000F11C011D111D81E4E81682E4F8068FE078
+:10798000080780E0180710F00E949D3C8091C0001D
+:1079900087FFECCF8091C6001F910F91FF90EF9071
+:1079A00008951F93182F03C00E94AE3C115011235D
+:1079B000D9F71F9108951F930E94AE3C182F0E9483
+:1079C000533C113614F0175503C010330CF010530C
+:1079D000812F1F9108951F930E94DB3C182F0E9456
+:1079E000DB3C1295107F810F1F9108950E94AE3CE1
+:1079F000803239F484E10E94533C80E10E94533C80
+:107A00000895809103018F5F80930301853011F405
+:107A10000E949D3C08951F93182F0E94AE3C803217
+:107A200051F484E10E94533C812F0E94533C80E139
+:107A30000E94533C09C0809103018F5F8093030132
+:107A4000853011F40E949D3C1F910895BF92CF9202
+:107A5000DF92EF92FF920F931F93CF93DF9300007B
+:107A60008FE98093C40081E08093C50098E19093F2
+:107A7000C10096E09093C2005098589A239A809340
+:107A8000B00089E08093B10089E68093B3008091D3
+:107A9000B00080648093B000259A81E00E94843C0D
+:107AA000BB24B3940E94AE3C803309F441C08133BF
+:107AB000E1F40E94AE3C803209F0ACC184E10E9446
+:107AC000533C81E40E94533C86E50E94533C82E58E
+:107AD0000E94533C80E20E94533C89E40E94533C44
+:107AE00083E50E94533C80E522C1803439F40E9432
+:107AF000AE3C8638E8F00E94AE3C1AC0813499F45E
+:107B00000E94AE3C803811F482E081C1813811F4CA
+:107B100081E07DC1823811F480E179C1883909F0B2
+:107B200075C183E074C1823431F484E10E94D13C98
+:107B30000E94F63CB7CF853411F485E0F7CF80354D
+:107B4000B9F38235A9F3813599F3853549F40E945B
+:107B5000AE3C809306010E94AE3C80930701E8CFC3
+:107B60008635C9F40E94AE3C803389F40E94AE3C55
+:107B70000E94AE3C082F0E94AE3C002311F48EE11F
+:107B800046C1013011F485E942C18FE040C183E074
+:107B90000E94D13C3BC1843609F0CFC00E94AE3C6C
+:107BA000809309020E94AE3C8093080280910C02EF
+:107BB0008E7F80930C020E94AE3C853429F4809124
+:107BC0000C02816080930C0208E011E06801EE2451
+:107BD000FF2408C00E94AE3CF60181936F01089417
+:107BE000E11CF11C8091080290910902E816F90647
+:107BF00088F30E94AE3C803209F00CC180910C02E7
+:107C000080FF2AC08091060190910701880F991F7B
+:107C1000909307018093060180E090E015C0F999E8
+:107C2000FECF209106013091070132BD21BDF80140
+:107C300041918F0140BDFA9AF99A2F5F3F4F3093DF
+:107C40000701209306010196209108023091090254
+:107C50008217930720F36AC080910701880F880B71
+:107C60008B2180930B028091060190910701880F70
+:107C7000991F90930701809306018091080280FF6D
+:107C800009C080910802909109020196909309021F
+:107C900080930802F894F999FECF1127E09106012C
+:107CA000F0910701C8E0D1E08091080290910902AB
+:107CB000103091F40091570001700130D9F303E0C6
+:107CC00000935700E8950091570001700130D9F3F7
+:107CD00001E100935700E895099019900091570031
+:107CE00001700130D9F301E000935700E895139536
+:107CF000103498F011270091570001700130D9F32A
+:107D000005E000935700E89500915700017001309D
+:107D1000D9F301E100935700E8953296029709F0F4
+:107D2000C7CF103011F00296E5CF112484E10E94F4
+:107D3000533C80E10E94533CB5CE843709F053C0D8
+:107D40000E94AE3C809309020E94AE3C80930802E0
+:107D50008091060190910701880F991F9093070168
+:107D6000809306010E94AE3C90910C02853411F480
+:107D7000916001C09E7F90930C020E94AE3C8032C5
+:107D800009F090CE84E10E94533C00E010E023C053
+:107D900080910C0280FF0BC0F999FECF8091060103
+:107DA0009091070192BD81BDF89A80B507C081FD11
+:107DB00007C0E0910601F091070184910E94533CB5
+:107DC000809106019091070101969093070180939D
+:107DD00006010F5F1F4F809108029091090208175A
+:107DE0001907B0F2A6CF853779F40E94AE3C8032F5
+:107DF00089F484E10E94533C8EE10E94533C85E962
+:107E00000E94533C8FE093CF863721F480E00E949C
+:107E10000B3D48CE809103018F5F80930301853035
+:0E7E200009F040CE0E949D3C3DCEF894FFCF6D
+:027E2E008000D2
+:040000030000780081
+:00000001FF
diff -urN arduino-1.8.5.orig/hardware/arduino/avr/cores/arduino/Tone.cpp arduino-1.8.5/hardware/arduino/avr/cores/arduino/Tone.cpp
--- arduino-1.8.5.orig/hardware/arduino/avr/cores/arduino/Tone.cpp	2017-10-02 15:37:16.000000000 +0200
+++ arduino-1.8.5/hardware/arduino/avr/cores/arduino/Tone.cpp	2017-10-06 16:10:22.727581211 +0200
@@ -533,7 +533,7 @@
 }
 #endif
 
-
+/*
 #ifdef USE_TIMER2
 ISR(TIMER2_COMPA_vect)
 {
@@ -557,7 +557,7 @@
   }
 }
 #endif
-
+*/
 
 #ifdef USE_TIMER3
 ISR(TIMER3_COMPA_vect)
diff -urN arduino-1.8.5.orig/libraries/Yeti/Examples/Demonstration/Demonstration.ino arduino-1.8.5/libraries/Yeti/Examples/Demonstration/Demonstration.ino
--- arduino-1.8.5.orig/libraries/Yeti/Examples/Demonstration/Demonstration.ino	1970-01-01 01:00:00.000000000 +0100
+++ arduino-1.8.5/libraries/Yeti/Examples/Demonstration/Demonstration.ino	2017-10-06 17:53:42.991282604 +0200
@@ -0,0 +1,74 @@
+#include <Servo.h>
+#include <Wire.h>
+#include <Yeti.h>                //include the yeti library
+#include <EEPROM.h>
+
+/*
+This program has been written do demonstrate how great Yeti is.
+Yeti does have to be calibrated before loading this program, or
+it might fall over or not walk properly.
+It starts by displaying 1234 on the display, if that is connected.
+Immediately after that, it swings its body from right to left.
+After that, it will make 6 steps forward and then make the front
+LED's act as a heartbeat.
+*/
+
+yeti robot;                    //create a yeti object
+
+int rightLED = 8;              //pin connected to the right led
+int leftLED = 2;               //pin connected to the left led
+
+//variables for heartbeat function, makes the front LEDs act like a heart :)
+uint8_t hbval=128;
+int8_t hbdelta=8;
+int timeInterval = 20;
+int timePrevious = 0;
+
+//used for swinging Yeti from side to side
+byte bodyRight = 3;
+byte bodyLeft = 4;
+byte bodyLevel = 5;
+
+
+void setup()
+{
+  robot.initYeti();                     //initialize the yeti program
+  robot.initPing();                     //initialize and enable the ultrasound
+  robot.initDisplay();                  //initialize and enable the display
+  
+  pinMode(rightLED, OUTPUT);            //set the pin attached to right led to output
+  pinMode(leftLED, OUTPUT);             //set the pin attached to left led to output
+  digitalWrite(rightLED, HIGH);         //switch the led on
+  robot.displayDigit(1, 2, 3, 4);       //display 1234 on the display
+  
+  robot.moveForwardX(0);
+  delay(300);
+  robot.moveBody(bodyRight);	        //swing Yeti's body to the right
+  delay(300);
+  robot.moveBody(bodyLeft);		        //swing to the left
+  delay(150);
+  robot.moveBody(bodyLevel);	        //level body
+    
+  robot.moveForwardX(6);                //make Yeti take 6 steps forward
+}
+
+void loop()
+{
+  //make Yeti's LEDs show a heartbeat
+  if(millis() - timePrevious > timeInterval)
+  {
+    if (hbval > 192) 
+      hbdelta = -hbdelta;
+    if (hbval < 16) 
+      hbdelta = -hbdelta;
+    hbval += hbdelta;
+    timePrevious = millis();
+  }
+  //no PWM on these pins so we have to get creative :)
+  digitalWrite(rightLED, HIGH);
+  digitalWrite(leftLED, LOW);
+  delayMicroseconds(255-hbval);
+  digitalWrite(rightLED, LOW);
+  digitalWrite(leftLED, HIGH);
+  delayMicroseconds(hbval);
+}
diff -urN arduino-1.8.5.orig/libraries/Yeti/Examples/Walk_10_steps_forward/Walk_10_steps_forward.ino arduino-1.8.5/libraries/Yeti/Examples/Walk_10_steps_forward/Walk_10_steps_forward.ino
--- arduino-1.8.5.orig/libraries/Yeti/Examples/Walk_10_steps_forward/Walk_10_steps_forward.ino	1970-01-01 01:00:00.000000000 +0100
+++ arduino-1.8.5/libraries/Yeti/Examples/Walk_10_steps_forward/Walk_10_steps_forward.ino	2017-10-06 17:53:42.991282604 +0200
@@ -0,0 +1,56 @@
+#include <Servo.h>
+#include <Wire.h>
+#include <Yeti.h>                //include the yeti library
+#include <EEPROM.h>
+
+/*
+Sketch written to test the yeti library, not to be released
+*/
+
+yeti robot;                    //create a yeti object
+
+int rightLED = 8;              //pin connected to the right led
+int leftLED = 2;               //pin connected to the left led
+
+//variables for heartbeat function
+uint8_t hbval=128;
+int8_t hbdelta=8;
+int timeInterval = 20;
+int timePrevious = 0;
+
+void setup()
+{
+  robot.initYeti();              //initialize the yeti program
+  robot.initPing();              //initialize and enable the display
+  robot.initDisplay();           //initialize and enable the display
+  
+  pinMode(rightLED, OUTPUT);     //set the pin attached to right led to output
+  pinMode(leftLED, OUTPUT);      //set the pin attached to left led to output
+  digitalWrite(rightLED, HIGH);  //switch the led on
+  digitalWrite(leftLED, HIGH);   //switch other LED on as well 
+
+  robot.moveForwardX(10);        //make Yeti take 10 steps forward
+}
+
+void loop()
+{
+  //make Yeti's LEDs show a heartbeat
+  if(millis() - timePrevious > timeInterval)
+  {
+    if (hbval > 192) 
+      hbdelta = -hbdelta;
+    if (hbval < 16) 
+      hbdelta = -hbdelta;
+    hbval += hbdelta;
+    timePrevious = millis();
+  }
+  //no PWM available, this calls for a bit of creativity. This is normally not 
+  //a very good way to do this, because it uses the delay function, but since
+  //the heartbeat is the only thing being executed, it's not important it is blocking
+  digitalWrite(rightLED, HIGH);
+  digitalWrite(leftLED, LOW);
+  delayMicroseconds(255-hbval);
+  digitalWrite(rightLED, LOW);
+  digitalWrite(leftLED, HIGH);
+  delayMicroseconds(hbval);
+}
diff -urN arduino-1.8.5.orig/libraries/Yeti/Examples/Yeti_Bluetooth/Yeti_Bleutooth.ino arduino-1.8.5/libraries/Yeti/Examples/Yeti_Bluetooth/Yeti_Bleutooth.ino
--- arduino-1.8.5.orig/libraries/Yeti/Examples/Yeti_Bluetooth/Yeti_Bleutooth.ino	1970-01-01 01:00:00.000000000 +0100
+++ arduino-1.8.5/libraries/Yeti/Examples/Yeti_Bluetooth/Yeti_Bleutooth.ino	2017-10-06 17:53:42.931278357 +0200
@@ -0,0 +1,32 @@
+#include <Servo.h>
+#include <Wire.h>
+#include <Yeti.h>                //include the yeti library
+#include <EEPROM.h>
+
+/*
+Sketch written to test the yeti library, not to be released
+*/
+
+yeti robot;                      //create a yeti object
+
+int rightLED = 8;                //pin connected to the right led
+int leftLED = 2;                 //pin connected to the left led
+
+void setup()
+{
+  robot.initYeti();              //initialize the yeti program
+  robot.initRF(9600);            //initialize the RF part of the library
+  
+  pinMode(rightLED, OUTPUT);     //set the pin attached to right led to output
+  pinMode(leftLED, OUTPUT);      //set the pin attached to left led to output
+  digitalWrite(rightLED, HIGH);  //switch the led on
+  digitalWrite(leftLED, HIGH);   //switch other LED on as well 
+
+  robot.moveForwardX(0);          //center Yeti
+}
+
+void loop()
+{
+  robot.getRFData();              //get data from the bluetooth module
+  robot.respondRF();              //move Yeti according to the data
+}
diff -urN arduino-1.8.5.orig/libraries/Yeti/Examples/Yeti_Calibration/Yeti_Calibration.ino arduino-1.8.5/libraries/Yeti/Examples/Yeti_Calibration/Yeti_Calibration.ino
--- arduino-1.8.5.orig/libraries/Yeti/Examples/Yeti_Calibration/Yeti_Calibration.ino	1970-01-01 01:00:00.000000000 +0100
+++ arduino-1.8.5/libraries/Yeti/Examples/Yeti_Calibration/Yeti_Calibration.ino	2017-10-06 17:53:42.991282604 +0200
@@ -0,0 +1,29 @@
+#include <Wire.h>
+#include <Yeti.h>
+#include <Servo.h>
+#include <EEPROM.h>
+
+/*
+This program has been designed to make use of the calibration function supplied in the 
+Yeti library. This program executes the calibration procedure, after uploading you need 
+to open the Serial Port viewer in the top right hand corner of the Arduino IDE. This will 
+guide you through the calibration process. See the manual for extra explanation of how 
+this works
+*/
+
+yeti robot;                             //make a Yeti object
+
+void setup()
+{
+  robot.initYeti();                     //initialize basic Yeti functionality 
+  robot.wirelessSerialInit();           //initialize the Serial port
+  robot.calibrate();                    //execute the calibration procedure
+  
+  robot.moveForwardX(0);                //center Yeti
+}
+
+void loop()
+{
+  //nothing to do here
+}
+  
diff -urN arduino-1.8.5.orig/libraries/Yeti/Examples/Yeti_Ultrasonic/Yeti_Ultrasonic.ino arduino-1.8.5/libraries/Yeti/Examples/Yeti_Ultrasonic/Yeti_Ultrasonic.ino
--- arduino-1.8.5.orig/libraries/Yeti/Examples/Yeti_Ultrasonic/Yeti_Ultrasonic.ino	1970-01-01 01:00:00.000000000 +0100
+++ arduino-1.8.5/libraries/Yeti/Examples/Yeti_Ultrasonic/Yeti_Ultrasonic.ino	2017-10-06 17:53:42.991282604 +0200
@@ -0,0 +1,40 @@
+#include <Servo.h>
+#include <Wire.h>
+#include <Yeti.h>           
+#include <EEPROM.h>
+
+/*
+This program has been designed to work with the ultrasonic expansion module
+which is available for the Yeti, if you also have the display module, you can
+uncomment the display setup and print functions and the distance will be 
+printed on the display
+*/
+
+yeti robot;                    //create a yeti object
+
+int rightLED = 8;              //pin connected to the right led
+
+
+void setup()
+{
+  robot.initYeti();                //initialize the yeti program
+  robot.initPing();                //initialize and enable the display
+  robot.moveForwardX(0);           //center Yeti
+  //robot.initDisplay();           //initialize and enable the display
+  //robot.displayDigit(1, 2, 3, 4);      //display 5678 on the display
+  
+  pinMode(rightLED, OUTPUT);       //set the pin to output
+  digitalWrite(rightLED, HIGH);    //switch the led on
+  
+  Serial.begin(57600);
+  Serial.println("setup done");
+}
+
+void loop()
+{
+  delay(1500);
+  int distanceToObject = robot.ping();
+  Serial.print("distance is: ");
+  Serial.println(distanceToObject);
+  //robot.displayDigit(distanceToObject);  
+}
diff -urN arduino-1.8.5.orig/libraries/Yeti/keywords.txt arduino-1.8.5/libraries/Yeti/keywords.txt
--- arduino-1.8.5.orig/libraries/Yeti/keywords.txt	1970-01-01 01:00:00.000000000 +0100
+++ arduino-1.8.5/libraries/Yeti/keywords.txt	2017-10-06 17:53:10.502312585 +0200
@@ -0,0 +1,39 @@
+#######################################
+# Syntax Coloring Map For Yeti
+#######################################
+
+#######################################
+# Datatypes (KEYWORD1)
+#######################################
+
+#######################################
+# Methods and Functions (KEYWORD2)
+#######################################
+
+initYeti	KEYWORD2
+calibrate	KEYWORD2
+wirelessSerialInit	KEYWORD2
+IRSerialprint	KEYWORD2
+IRSerialprintln	KEYWORD2
+IRSerialread	KEYWORD2
+moveForwardX	KEYWORD2
+moveForwardXNC	KEYWORD2
+moveBackwardXNC	KEYWORD2
+moveBody	KEYWORD2
+moveLegs	KEYWORD2
+beep	KEYWORD2
+initDisplay	KEYWORD2
+displayDigit	KEYWORD2
+initPing	KEYWORD2
+ping	KEYWORD2
+initRF	KEYWORD2
+getRFData	KEYWORD2
+respondRF	KEYWORD2
+updateCommand	KEYWORD2
+RFTest	KEYWORD2
+
+#######################################
+# Instances (KEYWORD1)
+#######################################
+
+yeti	KEYWORD1
diff -urN arduino-1.8.5.orig/libraries/Yeti/Yeti.cpp arduino-1.8.5/libraries/Yeti/Yeti.cpp
--- arduino-1.8.5.orig/libraries/Yeti/Yeti.cpp	1970-01-01 01:00:00.000000000 +0100
+++ arduino-1.8.5/libraries/Yeti/Yeti.cpp	2017-10-06 17:52:59.368189225 +0200
@@ -0,0 +1,851 @@
+#include <avr/io.h>
+#include <avr/interrupt.h>
+#include "Arduino.h"
+#include <Wire.h>
+#include <Servo.h>
+#include <EEPROM.h>
+#include "Yeti.h"
+
+/*
+ * Yeti.cpp: Library to control the walking yeti robot with Arduino
+ * Copyright (c) 2015 Thom Kouwen. All rights reserved.
+*/
+
+#define USE_TIMER1
+
+volatile unsigned long count80kHz;	// internal variable for the ultrasound sensor
+
+static inline void increaseCount()
+{
+	count80kHz++;
+}
+
+ISR(TIMER2_COMPA_vect)				// interrupt to increase count on count80kHz variable
+{
+	increaseCount();
+}
+
+ISR(ANALOG_COMP_vect)
+{
+	//PORTB &= ~(1 << PORTB1);
+}
+
+
+yeti::yeti()
+{
+	Wire.begin();					// start the I2C bus
+
+	count80kHz = 0;					// Initialize ultrasound sensor count
+
+	// Variable initialization:
+	beepNegative = 4;				// pin attached to the negative side of the beeper
+	beepPositive = 11;				// pin attached to the positive side of the beeper
+	leftLED = 2;					// Left LED (1) is attached to pin 2 on the Arduino
+	rightLED = 8;					// Right LED (2) is attached to pin 8 on the Arduino
+	pinMode(leftLED, OUTPUT);		// Set LED1 pin to output
+	pinMode(rightLED, OUTPUT);		// Set LED2 pin to output
+
+	displayAdress = 0x70 >> 1;		// I2C address of the 4* 7SEG driver chip, bit shifted because arduino uses 7 bit adresses
+
+	// Digits 0 to 9
+	digitsForDisplay[0] = 63;
+	digitsForDisplay[1] = 6;
+	digitsForDisplay[2] = 91;
+	digitsForDisplay[3] = 79;
+	digitsForDisplay[4] = 102;
+	digitsForDisplay[5] = 109;
+	digitsForDisplay[6] = 125;
+	digitsForDisplay[7] = 7;
+	digitsForDisplay[8] = 127;
+	digitsForDisplay[9] = 111;
+
+	// (Default) Variables to control servo movements
+	if(EEPROM.read(0) == 255)
+	{
+		posLean = 62;				// 62
+		posFwd = 65;				// 65
+		servoMid = 87;				// 87
+		negLean = 122;				// 122
+		negFwd = 109;				// 109
+	}
+	else
+	{
+		posLean = EEPROM.read(0);
+		posFwd = EEPROM.read(1);
+		servoMid = EEPROM.read(2);
+		negLean = EEPROM.read(3);
+		negFwd = EEPROM.read(4);
+	}
+
+	// Constants to keep track of the position of the legs/body
+	bodyPos = 0;
+	bodyLeftFwd = 1;
+	bodyRightFwd = 2;
+
+	leanRight = 3;
+	leanLeft = 4;
+	leanUp = 5;
+	prevLean = 0;
+
+	leftForward = 6;
+	rightForward = 7;
+	bodyLevel = 8;
+	prevMove = 0;
+
+	// Keep track of what Yeti is supposed to do
+	goForward = 0;
+	goLeft = 0;
+	goRight = 0;
+	goBackwards = 0;
+	prevMove = 0;
+}
+
+
+/* Iniitialize the Yeti */
+void yeti::initYeti()
+{
+	// Attach both servos to the two servo objects
+	servo1.attach(10);
+	servo2.attach(9);
+	servo1.write(87);
+	servo2.write(87);
+
+	// Set LED Pin modes
+	pinMode(rightLED, OUTPUT);
+	pinMode(leftLED, OUTPUT);
+}
+
+
+/* Run the leg calibration procedure */
+void yeti::calibrate()
+{
+	IRSerialprintln("Yeti calibration procedure started");
+	IRSerialprintln("Are you sure you want to calibrate me? Type Y or N and press enter");
+	// Center both servos, to give users the ability to mount the servo arms at servo center
+	servo1.write(87);
+	servo1.write(87);
+	while(Serial.available() == 0)
+		delay(100);						// Wait for response
+	char doCalibrate = Serial.read();	// Get response
+	// Check and see if the user wants to enter calibration procedure
+	if(doCalibrate == 'Y' || doCalibrate == 'y')
+	{
+		// Explain how the calibration works
+		IRSerialprintln("type + or - and press enter to edit value, type X to stop");
+		IRSerialprintln("Type S to save value");
+		IRSerialprintln("We will start at the front servo, first point is lean right");
+
+		int tempServo1 = 87;			// Servo position from which we are going to start
+		int servoPos = 0;				// Which position are we calibrating, 0 = lean right, 1 = center and 2 is lean left
+		servo1.write(tempServo1);
+		// Here we are going to calibrate the front servo, or servo1
+		while(servoPos < 3)
+		{
+			while(Serial.available() == 0);	//wait for something to happen on the serial bus
+			char servoTempValue = Serial.read();
+			if(servoTempValue == '+')
+				tempServo1++;
+
+			else if(servoTempValue == '-')
+				tempServo1--;
+		
+			else if(servoTempValue == 'X' || servoTempValue == 'x')
+				break;
+
+			else if(servoTempValue == 'S' || servoTempValue == 's')
+			{
+				if(servoPos == 2)
+				{
+					negLean = tempServo1;
+					IRSerialprintln("Lean left saved, now on to bottom servo calibration");
+				}
+				else if(servoPos == 1)
+				{
+					leanUp = tempServo1;
+					IRSerialprintln("Center saved, now onto lean left");
+				}
+				else
+				{
+					posLean = tempServo1;
+					IRSerialprintln("Lean right saved, onto center");
+				}
+				servoPos++;
+			}
+			else
+				IRSerialprintln("Error, invalid entry");
+			servo1.write(tempServo1);
+		}
+		servo1.write(leanUp);
+
+		IRSerialprintln("Bottom servo, first calibration point is right forward");
+		IRSerialprintln("Type S to save value");
+		int tempServo2 = 87;
+		servoPos = 0;				// Which position are we calibrating, 0 = right forward, 1 = center and 2 is left forward
+		servo2.write(tempServo2);
+
+		// Here we are going to calibrate the bottom servo, or servo2
+		while(servoPos < 3)
+		{
+			while(Serial.available() == 0);   // Wait for something to happen on the serial bus
+			char servoTempValue = Serial.read();
+			if(servoTempValue == '+')
+				tempServo2++;
+
+			else if(servoTempValue == '-')
+				tempServo2--;
+
+			else if(servoTempValue == 'X' || servoTempValue == 'x')
+				break;
+
+			else if(servoTempValue == 'S' || servoTempValue == 's')
+			{
+				if(servoPos == 2)
+				{
+					negFwd = tempServo2;
+					IRSerialprintln("Left forward saved, we are done now");
+				}
+				else if(servoPos == 1)
+				{
+					servoMid = tempServo2;
+					IRSerialprintln("Center saved, now onto left forward");
+				}
+				else
+				{
+					posFwd = tempServo2;
+					IRSerialprintln("Right forward saved, onto center");
+				}
+				servoPos++;
+			}
+			else
+				IRSerialprintln("Error, invalid entry");
+			servo2.write(tempServo2);
+		}
+		servo2.write(servoMid);
+		EEPROM.write(0, posLean);
+		EEPROM.write(1, posFwd);
+		EEPROM.write(2, servoMid);
+		EEPROM.write(3, negLean);
+		EEPROM.write(4, negFwd);
+	}
+	else
+		IRSerialprintln("calibration cancelled");
+}
+
+
+/* Initialize the serial IR transceiver */
+void yeti::wirelessSerialInit()
+{
+	Serial.begin(2400);
+	// PWM setup for IR Serial at 38kHz
+	pinMode(11, OUTPUT);
+	// Setup timer 2 for PWM on PB3
+	TCCR2A = _BV(WGM20);
+	TCCR2B = _BV(WGM22) | _BV(CS20); 
+
+	// setup timer2 top value - freq = FCPU / 4 / OCR2A
+	OCR2A = F_CPU / 4 / 38000;		// 52 for 8MHz, 105 for 16MHz  
+	//TCCR2A |= _BV(COM2A0);		// Enable pwm on pin 11 (the IR LED)
+}
+
+
+/* Send data to the serial IR transceiver */
+void yeti::IRSerialprint(int TXData)
+{
+	while (!(UCSR0A & _BV(UDRE0)));	// Wait until input buffer is clear
+	UCSR0B &= ~(1<<RXEN0);			// Disable the receiver
+	TCCR2A |= (1<<COM2A0);
+	delay(1);
+
+	Serial.print(char(TXData));		// Send the data 
+	while (!(UCSR0A & _BV(TXC0)));	// Wait until all data has been transmitted
+	TCCR2A &= ~(1<<COM2A0);
+
+	delay(5);						// Add small delay to prevent receiving of reflections
+	UCSR0B |= (1<<RXEN0);			// Enable the receiver again
+}
+
+
+/* Send data and a newline to the serial IR transceiver */
+void yeti::IRSerialprintln(int TXData)
+{
+	while (!(UCSR0A & _BV(UDRE0)));	// Wait until input buffer is clear
+	UCSR0B &= ~(1<<RXEN0);			// Disable the receiver
+	TCCR2A |= (1<<COM2A0);
+	delay(1);
+
+	Serial.print(char(TXData));		// Send the data 
+	Serial.println();				// Send newline
+	while (!(UCSR0A & _BV(TXC0)));	// Wait until all data has been transmitted
+	TCCR2A &= ~(1<<COM2A0);
+
+	delay(5);						// Add small delay to prevent receiving of reflections
+	UCSR0B |= (1<<RXEN0);			// Enable the receiver again
+}
+
+
+/* Send a string to the serial IR transceiver */
+void yeti::IRSerialprint(String TXData)
+{
+	while (!(UCSR0A & _BV(UDRE0)));		// Wait until input buffer is clear
+	UCSR0B &= ~(1<<RXEN0);				// Disable the receiver
+	TCCR2A |= (1<<COM2A0);
+	delay(1);
+
+	Serial.print(TXData);    			// Send the string
+	while (!(UCSR0A & _BV(TXC0)));		// Wait until all data has been transmitted
+	TCCR2A &= ~(1<<COM2A0);
+
+	delay(5);							// Add small delay to prevent receiving of reflections
+	UCSR0B |= (1<<RXEN0);				// Enable the receiver again
+}
+
+
+/* Send a line of text (string + newline) to the serial IR transceiver */
+void yeti::IRSerialprintln(String TXData)
+{
+	while (!(UCSR0A & _BV(UDRE0)));		// Wait until input buffer is clear
+	UCSR0B &= ~(1<<RXEN0);				// Disable the receiver
+	TCCR2A |= (1<<COM2A0);
+	delay(1);
+
+	Serial.print(TXData);				// Send the string
+	Serial.println();					// Send newline
+	while (!(UCSR0A & _BV(TXC0)));		// Wait until all data has been transmitted
+	TCCR2A &= ~(1<<COM2A0);
+
+	delay(5);							// Add small delay to prevent receiving of reflections
+	UCSR0B |= (1<<RXEN0);				// Enable the receiver again
+}
+
+
+/* Read data from the serial IR transceiver */
+int yeti::IRSerialread()
+{
+	return Serial.read();				// Just return serial data 
+}
+
+
+/* Make Yeti move nrSteps steps forward */
+void yeti::moveForwardX(int nrSteps)
+{
+	if(nrSteps != 0)
+	{
+		for(int currentNumberSteps = 0; currentNumberSteps < nrSteps; currentNumberSteps++)
+		{
+			moveForwardXNC();
+		}
+	}
+
+	moveBody(leanUp);
+	moveLegs(bodyLevel);
+}
+
+
+/* Make Yeti move one step forward, don't center legs afterwards */
+void yeti::moveForwardXNC()
+{
+	if(bodyPos == bodyLeftFwd)		// If left is currently in front, go here
+	{
+		moveBody(leanLeft, 16);
+		moveLegs(rightForward, 13);
+		moveBody(leanUp, 16);
+		bodyPos = bodyRightFwd;
+	}
+	else
+	{
+		moveBody(leanRight, 16);
+		moveLegs(leftForward, 13);
+		moveBody(leanUp, 16);
+		bodyPos = bodyLeftFwd;
+	}
+}
+
+
+/* Make Yeti move one step backward, don't center legs afterwards */
+void yeti::moveBackwardXNC()
+{
+	if(bodyPos == bodyLeftFwd)
+	{
+		moveBody(leanRight, 16);
+		moveLegs(rightForward, 16);
+		moveBody(leanUp, 16);
+		bodyPos = bodyRightFwd;
+	}
+	else
+	{
+		moveBody(leanLeft, 16);
+		moveLegs(leftForward, 16);
+		moveBody(leanUp, 16);
+		bodyPos = bodyLeftFwd;
+	}
+}
+
+
+/* Make Yeti turn right by the specified angle */
+void yeti::turnRight(int angle)
+{
+	moveBody(leanLeft, 15);
+	moveLegs(leftForward, 15);
+	moveBody(leanUp, 16);
+	delay(150);
+	if(angle == 0)
+		moveLegs(bodyLevel, 16);
+	else
+		moveLegs(rightForward, 16);
+	moveBody(leanRight, 17);
+	moveLegs(bodyLevel, 17);
+	moveBody(leanUp, 17);
+}
+
+
+/* Make Yeti turn left by the specified angle */
+void yeti::turnLeft(int angle)
+{
+	moveBody(leanRight, 15);
+	moveLegs(rightForward, 15);
+	moveBody(leanUp, 16);
+	delay(100);
+	if(angle == 0)
+		moveLegs(bodyLevel, 16);
+	else
+		moveLegs(leftForward, 16);
+	moveBody(leanLeft, 17);
+	moveLegs(bodyLevel, 17);
+	moveBody(leanUp, 17);
+}
+
+
+/* Make Yeti lean his body (3 = right, 4 = left) */
+void yeti::moveBody(int leanDirection, int delayFactor)
+{
+	if(leanDirection == leanRight)
+	{
+		for (int i = servo1.read(); i != posLean; i--)
+		{
+			delay(1 * delayFactor);
+			servo1.write(i);
+		}
+		prevLean = leanRight;
+	}
+	else if(leanDirection == leanLeft)
+	{
+		for (int i = servo1.read(); i != negLean; i++)
+		{
+			delay(1 * delayFactor);
+			servo1.write(i);
+		}
+		prevLean = leanLeft;
+	}
+	else
+	{
+		if(prevLean == leanRight)
+		{
+			for(int i = servo1.read(); i != servoMid; i++)
+			{
+				servo1.write(i);
+				delay(1 * delayFactor);
+			}
+		}
+		else if(prevLean == leanLeft)
+		{
+			for(int i = servo1.read(); i != servoMid; i--)
+			{
+				servo1.write(i);
+				delay(1 * delayFactor);
+			}
+		}
+	}
+}
+
+
+/* Make Yeti move his legs (left forward = 6, right forward = 7) */
+void yeti::moveLegs(int walkDirection, int delayFactor)
+{
+	if(walkDirection == rightForward)
+	{
+		for (int i = servo2.read(); i != posFwd; i--)
+		{
+			delay(2 * delayFactor);
+			servo2.write(i);
+		}
+   }
+   else if(walkDirection == leftForward)
+   {
+		for (int i = servo2.read(); i != negFwd; i++)
+		{
+			delay(2 * delayFactor);
+			servo2.write(i);
+		}
+   }
+   else
+   {   
+		int servoUpDown;
+		if(servo2.read() > servoMid)
+			servoUpDown = 1;
+		else
+			servoUpDown = 0;
+		for(int i = servo2.read(); i!= servoMid; i)
+		{
+			servo2.write(i);
+			if(servoUpDown == 0)
+				i++;
+			else
+				i--;
+			delay(2*delayFactor);
+		}
+   }
+}
+
+
+/* Sound the buzzer (Serial communication is not possible during beeps!)
+ */
+void yeti::beep(int frequency, int duration)
+{
+	pinMode(beepNegative, OUTPUT);
+	pinMode(beepPositive, OUTPUT);
+	digitalWrite(beepNegative, HIGH);
+	tone(11, frequency, duration);
+}
+
+
+/* Initialize the 7 segment 4 digit display module */
+void yeti::initDisplay()
+{
+	Wire.beginTransmission(displayAdress);
+	Wire.write(B00000000);			// This is the instruction byte. Zero means the next byte is the control byte
+	Wire.write(B01000111);			// Control byte (dynamic mode on, digits 1+3 on, digits 2+4 on, 12mA segment current
+	Wire.endTransmission();         // Send the buffered data
+}
+
+
+/* Display a 4 digit number */
+void yeti::displayDigit(int displayNumber)
+{
+	int j = displayNumber;
+	int displayBCD[4];
+	for(int i = 0; i != 4; i++)
+	{
+		displayBCD[i] = j % 10;
+		j /= 10;
+	}
+	Wire.beginTransmission(displayAdress);
+	Wire.write(0x01);				// Instruction byte, start on the right-hand side
+	Wire.write(digitsForDisplay[displayBCD[0]]);
+	Wire.write(digitsForDisplay[displayBCD[2]]);
+	Wire.write(digitsForDisplay[displayBCD[1]]);
+	Wire.write(digitsForDisplay[displayBCD[3]]);
+	Wire.endTransmission();
+}
+
+
+/* Display single digits */
+void yeti::displayDigit(int firstDigit, int secondDigit, int thirdDigit,
+	int forthDigit)
+{
+	Wire.beginTransmission(displayAdress);
+	Wire.write(0x01);				// Write instruction byte, start on right-hand side
+	// Write the 4 digits
+	Wire.write(digitsForDisplay[forthDigit]);
+	Wire.write(digitsForDisplay[secondDigit]);
+	Wire.write(digitsForDisplay[thirdDigit]);
+	Wire.write(digitsForDisplay[firstDigit]);
+
+	Wire.endTransmission();
+}
+
+
+/* Initialize the ultrasound sensor */
+void yeti::initPing()
+{
+	noInterrupts();					// Temporarily disable interrupts
+	TCCR2A = (1<< WGM21);			// CTC, no IO toggling
+	OCR2A = 0xC7;					// 80 kHz
+	ADCSRA = 0;						// Disable ADC, leave settings intact
+	ADMUX = 0x00;					// Multiplexer for comparator to ADC0
+	ADCSRB = (1 << ACME);			// Enable the multiplexer
+	//ACSR = 0x02;					// React on falling edge, no interrupt
+	ACSR = B00010011;
+	interrupts();					// Enable interrupts again  
+}
+
+
+/* Sleep function */
+void yeti::usleep(unsigned long us)
+{
+	count80kHz = 0;
+	while(count80kHz * 25/2 < (2 * us));
+}
+
+
+/* Get the current distance measurement from ultrasound sensor */
+int yeti::ping()
+{
+	noInterrupts();					// Disable interrupts again
+	pinMode(11, OUTPUT);			// Set pin B3 to output
+	pinMode(9, OUTPUT);
+
+	TCCR2A = (1 << COM2A0) | (1<< WGM21);	// Start toggling on OC2A
+	TCCR2B = (1 << CS20);			// No pre-scale
+	OCR2A = 0xC7;					// Set frequency to about 40kHz
+	TIMSK2 = (1 << OCIE2A);			// Enable Compare Match A interrupt
+	interrupts();					// Enable interrupts again
+	count80kHz = 0;
+
+	while(count80kHz < 20)			// Send 10 pulses
+	{
+		//OCR2A = 0xC7 + (int(10)-count80kHz); //slightly play with the frequency 0xC7
+	}
+
+	noInterrupts();
+	TCCR2A = (1<< WGM21);			// CTC, no IO toggling
+	interrupts();					// Enable interrupts again
+
+	distancePos = 0;
+ 
+	for(int pos = 0; pos < 150; pos++)	// If it takes longer then this the sensor is out of range
+	{
+		usleep(23);
+		if((ACSR &(1 << ACI)) != 0)	// If ACI is set, we got a signal from the sensor
+		{
+			if(distancePos == 0)	// If distance is already set, don't set it again
+				distancePos = pos;
+		}
+
+		ACSR |= (1 << ACI);
+	}
+	return distancePos;
+}
+
+
+/* Initialize the wireless module */
+void yeti::initRF(int baudrate)
+{
+	Serial.begin(baudrate);
+	inByte = 0;						// Initialize incoming serial bytes
+	inByte1 = 0;
+	inByte2 = 0;
+	inByte3 = 0;
+	inByte4 = 0;
+	inByte5 = 0;
+	inByte6 = 0;
+	inByte7 = 0;
+	inByte8 = 0;
+}
+
+
+/* Get data from the wireless module */
+void yeti::getRFData()
+{
+	if(Serial.available() >= 8)
+	{
+		for(int i = Serial.available(); i >= 0; i -= 9)
+		{
+			// Get incoming bytes:
+			Serial.print("Byte0: "); Serial.println(inByte  = Serial.read());
+			Serial.print("Byte1: "); Serial.println(inByte1 = Serial.read());
+			Serial.print("Byte2: "); Serial.println(inByte2 = Serial.read());
+			Serial.print("Byte3: "); Serial.println(inByte3 = Serial.read()); // Control
+			Serial.print("Byte4: "); Serial.println(inByte4 = Serial.read()); // Info1
+			Serial.print("Byte5: "); Serial.println(inByte5 = Serial.read()); // Info2
+			Serial.print("Byte6: "); Serial.println(inByte6 = Serial.read()); // Info3
+			Serial.print("Byte7: "); Serial.println(inByte7 = Serial.read()); // Info4
+			Serial.read();
+			Serial.write(inByte4);
+
+			switch (inByte5)
+			{
+				case 102: 
+				{
+					goForward = 0;
+					goLeft = 0;
+					goRight = 0;
+					goBackwards = 0;
+					prevMove = 1;
+				} break;	// STOP
+
+				case 53: 
+				{
+					goForward = 0;
+					goLeft = 0;
+					goRight = 0;
+					goBackwards = 0;
+					prevMove = 1;
+				} break;	// STOP
+
+				case 128: 
+				{
+					goForward = 1;
+					goRight = 0;
+					goLeft = 0;
+					goBackwards = 0;
+				} break;	// FORWARD
+
+				case 56: 
+				{
+					goForward = 1;  
+					goRight = 0;
+					goLeft = 0;
+					goBackwards = 0;
+				} break;	// FORWARD
+
+				case 96: 
+				{
+					if(inByte6 == 102)
+					{
+						// Turn on LEDs
+						digitalWrite(leftLED, HIGH);
+						digitalWrite(rightLED, HIGH);
+					}
+					else if(inByte6 == 6)
+					{
+						// Turn off LEDs
+						digitalWrite(leftLED, LOW);
+						digitalWrite(rightLED, LOW);
+					}
+					else if(((inByte6 & 0x18)== 0x18) || inByte5 == 52)
+					{
+						goLeft = 1;
+						goForward = 0;
+						goRight = 0;
+						goBackwards = 0;
+					}	// LEFT
+				}   break;
+
+				case 52: 
+				{
+					goLeft = 1;
+					goForward = 0;
+					goRight = 0;
+					goBackwards = 0;
+				}   break;	// LEFT
+
+				case 120: 
+				{
+					goRight = 1; 
+					goLeft = 0;
+					goBackwards = 0;
+					goForward = 0;
+				} break;	// RIGHT
+
+				case 54: 
+				{
+					goRight = 1; 
+					goLeft = 0;
+					goBackwards = 0;
+					goForward = 0;
+				} break;	// RIGHT
+
+				case 24:
+				{
+					if(prevMove == 1);
+					else
+					{
+						goBackwards = 1;
+						goLeft = 0;
+						goRight = 0;
+						goForward = 0;
+					}
+				} break;	// BACKWARD
+
+				case 50:
+				{
+					if(prevMove == 1);
+					else
+					{
+						goBackwards = 1;
+						goLeft = 0;
+						goRight = 0;
+						goForward = 0;
+					}
+				} break;	// BACKWARD
+
+			}
+			if(inByte3 == 3) 
+				RFTest();
+			else if(inByte3 == 2)
+				respondRF();
+		}
+
+		while(Serial.available() > 0)
+			char t = Serial.read();
+	}
+}
+
+
+/* Move Yeti according to wireless command, send data back
+ * (servo position, etc.) */
+void yeti::respondRF()
+{
+	if(goForward == 1)
+		moveForwardXNC();
+	else if(goRight == 1)
+		turnRight(1);
+	else if(goLeft == 1)
+		turnLeft(1);
+	else if(goBackwards == 1)
+		moveBackwardXNC();
+	else
+		{
+			if(prevMove)
+			{
+				moveLegs(leanUp, 25);
+				moveBody(bodyLevel, 25);
+				prevMove = 0;
+			}
+		}
+}
+
+
+/* Return data about the current state of Yeti to the wireless module */
+void yeti::updateCommand()
+{
+	int servo1Pos, servo2Pos;
+	servo1Pos = servo1.read();		// Get current position of the front servo
+	servo2Pos = servo2.read();		// Get current position of the bottom servo
+
+	// Disable the pull-ups on the I2C bus to get accurate values
+	pinMode(5, INPUT);
+	pinMode(19, INPUT);
+	digitalWrite(5, LOW);
+	digitalWrite(19, LOW);
+
+	int batteryVoltage = analogRead(19);
+	batteryVoltage /= 45;			// Scale battery voltage from 0-255
+
+	// Enable the pull-up on the I2C bus again
+	pinMode(5, OUTPUT);
+	digitalWrite(5, HIGH);
+
+	// Send all of the data
+	Serial.write(1);					// Start Byte: 1
+	Serial.write(255);					// Address PC: 255
+	Serial.write(14);					// Length: 14
+	Serial.write(254);					// Command: 254 "update data"
+	Serial.write(batteryVoltage);		// Data 0: battery voltage
+	Serial.write((byte)0x00);			// Data 1: current motor right, not available for Yeti
+	Serial.write((byte)0x00);			// Data 2: current motor left, not available for Yeti
+	Serial.write(servo1Pos);			// Data 3: front servo position
+	Serial.write(servo2Pos);			// Data 4: bottom servo position
+	Serial.write((byte)0x00);			// Data 5: errorbits
+	Serial.write((byte)0x00);			// Data 6: linesensor left, not available
+	Serial.write((byte)0x00);			// Data 7: linesensor right, not available
+	Serial.write((byte)0x00);			// Data 8: Servo disabled
+	Serial.write(4);					// Stopbit
+}
+
+
+/* Test wireless connection */
+void yeti::RFTest()
+{
+	delay(100);
+	for(int Test_Value_RF =0; Test_Value_RF<10; Test_Value_RF++)
+	{
+		Serial.write(1);				// Start Byte:		1
+		Serial.write(255);				// Address PC:		255 
+		Serial.write(6);				// Length: 			7 bytes 
+		Serial.write(200);				// Control Byte:		200
+		Serial.write((byte)0x10);		// Data byte 0:		10
+		Serial.write(4);				// Stop Byte:		4
+		delay(250);
+	}
+}
diff -urN arduino-1.8.5.orig/libraries/Yeti/Yeti.h arduino-1.8.5/libraries/Yeti/Yeti.h
--- arduino-1.8.5.orig/libraries/Yeti/Yeti.h	1970-01-01 01:00:00.000000000 +0100
+++ arduino-1.8.5/libraries/Yeti/Yeti.h	2017-10-06 17:53:05.465288514 +0200
@@ -0,0 +1,92 @@
+#ifndef YETI_h
+#define YETI_h
+
+#include <avr/interrupt.h>
+#include "Arduino.h"
+#include <Wire.h>
+#include <Servo.h>
+#include <EEPROM.h>
+
+/*
+ * Yeti.h: Library to control the walking yeti robot with Arduino
+ * Copyright (c) 2015 Thom Kouwen. All rights reserved.
+*/
+
+
+class yeti
+{
+	private:
+		Servo servo1;					// Servo object 1 (Front Servo)
+		Servo servo2;					// Servo object 2 (Bottom Servo)
+
+		unsigned int distancePos;		// Ultrasound distance in cm
+		
+		int beepNegative;				// pin attached to the negative side of the beeper
+		int beepPositive;				// pin attached to the positive side of the beeper
+		int leftLED;					// Left LED (1) pin
+		int rightLED;					// Right LED (2) pin
+
+		int displayAdress;				// I2C address of the 4* 7SEG driver chip, bit shifted because arduino uses 7 bit adresses
+		int digitsForDisplay[10];		// Digits 0 to 9
+
+		// Variables to control servo movements
+		int posLean, negLean, posFwd, negFwd;
+		int servoMid;
+
+		// Variables / Constants to keep track of the position of the legs/body
+		int bodyPos;
+		int bodyLeftFwd, bodyRightFwd;
+
+		int leanRight, leanLeft, leanUp;
+		int prevLean;
+
+		int leftForward, rightForward, bodyLevel;
+		int leanCurrent, bodyCurrent;
+		
+		int goForward, goLeft, goRight, goBackwards, prevMove;
+		
+		// Variables for the RF stuff
+		byte inByte, inByte1, inByte2, inByte3, inByte4, 
+			inByte5, inByte6, inByte7, inByte8;
+	
+	
+	public:
+
+		yeti();
+		void initYeti();
+		void calibrate();						// Calibrate Yeti's legs 
+		
+		void wirelessSerialInit();				// Initialize the wireless serial module
+		void IRSerialprint(int TXData);			// Send a byte over the IR serial port
+		void IRSerialprintln(int TXData);		// Send a byte and a newline over the IR serial port
+		void IRSerialprint(String TXData);		// Send a string over the IR serial port
+		void IRSerialprintln(String TXData);	// Send a string and newline over the IR serial port
+		int  IRSerialread();					// Read data from the serial bus
+
+		void moveForwardX(int nrSteps);			// Make yeti walk in a straight line
+		void moveForwardXNC();					// Make yeti walk, no centering on exit
+		void moveBackwardXNC();					// Make yeti walk backwards, no centering on exit
+		void turnRight(int angle);				// Make yeti turn right
+		void turnLeft(int angle);				// Make yeti turn left
+		void moveBody(int leanDirection, int delayFactor = 13);	// Move yeti's body
+		void moveLegs(int walkDirection, int delayFactor = 10);	// Move yeti's legs
+
+		void beep(int frequency, int duration);	// Sound the buzzer
+		void initDisplay();						// Initialize the display
+		void displayDigit(int displayNumber = 0000);	// Display a 4 digit number 
+		void displayDigit(int firstDigit, int secondDigit, 
+			int thirdDigit, int forthDigit);	// Display single digits
+
+		void usleep(unsigned long us);			// Sleep function
+		void increaseCount();
+		void initPing();						// Initialise the ultrasound sensor
+		int  ping();							// Get the current distance measurement from ultrasound sensor
+
+		void initRF(int baudrate);				// Initialize for the wireless module
+		void getRFData();						// Get data from the wireless module
+		void respondRF();						// Move Yeti according to wireless command, send data back (servo position, etc.)
+		void updateCommand();					// Return data about the current state of Yeti to the wireless module
+		void RFTest();							// Test wireless connection
+};
+
+#endif
